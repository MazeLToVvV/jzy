<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GO Jzy</title>
    <link>https://YoungJzy.github.io/</link>
    <description>Recent content on GO Jzy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2019 Jzy.</copyright>
    <lastBuildDate>Thu, 28 Mar 2019 14:40:23 +0800</lastBuildDate>
    
	<atom:link href="https://YoungJzy.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>取整</title>
      <link>https://YoungJzy.github.io/golang/%E5%8F%96%E6%95%B4/</link>
      <pubDate>Wed, 27 Mar 2019 16:26:14 +0800</pubDate>
      
      <guid>https://YoungJzy.github.io/golang/%E5%8F%96%E6%95%B4/</guid>
      <description>golang中的向上取整，向下取整，以及四舍五入
概述  官方的math包只给了向上和向下取整，分别是math.Ceil()[向上取整]，math.Floor()[向下取整]，并没有四舍五入的直接方法，但是我们可以通过向下取整变相的实现四舍五入。  用法 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main(){ x := 1.1 fmt.Println(math.Ceil(x)) // 输出为2 fmt.Println(math.Floor(x)) // 输出为1 }  四舍五入  Word&amp;rsquo;s cheap, show u my code  package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main(){ x := 1.1 y := 1.6 fmt.Println(math.Floor(x + 0.5)) // 输出为1 fmt.Println(math.Floor(y + 0.5)) // 输出为2 }  很简单吧～</description>
    </item>
    
    <item>
      <title>Goroutine的管理</title>
      <link>https://YoungJzy.github.io/golang/goroutine%E7%9A%84%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 22 Mar 2019 15:52:26 +0800</pubDate>
      
      <guid>https://YoungJzy.github.io/golang/goroutine%E7%9A%84%E7%AE%A1%E7%90%86/</guid>
      <description>Goroutine的管理有两种方式： - WaitGroup - Context
什么是WaitGroup 顾名思义，WaitGroup是等待组，即设置一个等待组，来等待goroutine的执行，只有当设置等待的goroutine的数量达到目标数之后，程序才会继续向下执行。
func main() { var wg sync.WaitGroup wg.Add(2) go func() { defer wg.Done() time.Sleep(2*time.Second) fmt.Println(&amp;quot;1号完成&amp;quot;) }() go func() { defer wg.Done() time.Sleep(2*time.Second) fmt.Println(&amp;quot;2号完成&amp;quot;) }() wg.Wait() fmt.Println(&amp;quot;好了，大家都完成了，解散&amp;quot;) }  一个很简单的例子，一定要例子中的2个goroutine都完成任务，才算是完成，先做好的需要等待未完成的Goroutine，所有的goroutine要都全部完成才可以。就好比军训时，教官让学员报数，到达场地的学员应到28人，实到28人时，开始训练，实到人数没有达到应到人数，则一直等待。
chan通知 WaitGroup是一种被动式（等待式）的控制并发的方法，有时候一个goroutine我们需要它一直工作，直到发起让一个goroutine停止工作的命令，这种情况下就需要主动式的控制并发的方法。
这样我们就需要设置一个goroutine和主程序都读的到的变量，让goroutine运行是一直监听该变量，变量变为停止，则停止执行。golang中有一种通道类型（chan），可以更方便的完成上述操作，通过chan + select方法。
func main() { stopCh := make(chan bool) go func() { for { select { case &amp;lt;-stopCh: fmt.Println(&amp;quot;打卡下班...&amp;quot;) return default: fmt.Println(&amp;quot;goroutine工作中...&amp;quot;) time.Sleep(2 * time.Second) } } }() time.Sleep(10 * time.Second) fmt.</description>
    </item>
    
    <item>
      <title>Haproxy配置tcp转发</title>
      <link>https://YoungJzy.github.io/kubernetes/haproxy%E9%85%8D%E7%BD%AEtcp%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Thu, 25 Jul 2019 15:11:13 +0800</pubDate>
      
      <guid>https://YoungJzy.github.io/kubernetes/haproxy%E9%85%8D%E7%BD%AEtcp%E8%BD%AC%E5%8F%91/</guid>
      <description>在生产上碰到这样一个问题： 租户的请求是tcp的请求，而haproxy-ingress默认是转发http请求的，导致用户请求时总是报超时。
于是我们需要进行修改，使得haproxy监听端口来转发tcp的流量。
解决方法： 一、创建一个需要转发tcp流量应用对应的configmap配置文件：  $ vim tcp-configmap-sample.yaml  apiVersion: v1 kind: ConfigMap metadata: name: demo-ha-tcp-ingress-configmap namespace: &amp;quot;demonamespace&amp;quot; data: 3355: &amp;quot;demonamespace/demo-svc:8080&amp;quot;  当把这个configmap配置到haproxy的deployment后，haproxy的容器中就会监听这个3355端口来转发tcp的流量到demo-svc的8080端口
二、配置haproxy，讲configmap应用起来：  $ kubectl -n demonamespace edit deployment demo-haproxy  在container的args处添加- —tcp-services-configmap参数然后将上面创建configmap所在的命名空间和configmap名填写在该参数后面
containers: - args: - --default-backend-service=$(POD_NAMESPACE)/demo-svc - --default-ssl-certificate=$(POD_NAMESPACE)/tls-secret - --ingress-class=ha-demo - --tcp-services-configmap=$(POD_NAMESPACE)/demo-ha-tcp-ingress-configmap  配置好configmap后，将3355端口映射出来，给外部访问： containers: - args: - --default-backend-service=$(POD_NAMESPACE)/hx-xl-iot-kpi-svc - --default-ssl-certificate=$(POD_NAMESPACE)/tls-secret - --ingress-class=ha-hx-xl-iot-kpi - --tcp-services-configmap=$(POD_NAMESPACE)/iothaproxy-tcp-ingress-configmap ······ ports: - containerPort: 80 // ---&amp;gt; 将这个80改为3355 hostPort: 30035 name: http protocol: TCP - containerPort: 443 name: https protocol: TCP - containerPort: 1936 hostPort: 19035 name: stat protocol: TCP  若需要添加一个端口映射，只需复制port映射的配置即可，这样会映射两个端口，一个监听http流量转发，一个监听tcp流量转发</description>
    </item>
    
    <item>
      <title>Goroutine调度器</title>
      <link>https://YoungJzy.github.io/goodposts/goroutine%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Thu, 28 Mar 2019 16:11:57 +0800</pubDate>
      
      <guid>https://YoungJzy.github.io/goodposts/goroutine%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description> 概述 Go采用了用户层轻量级thread或者说是类coroutine的概念来解决这些问题，Go将之称为”goroutine“。goroutine占用的资源非常小(Go 1.4将每个goroutine stack的size默认设置为2k)，goroutine调度的切换也不用陷入(trap)操作系统内核层完成，代价很低。因此，一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在goroutine中执行，哪怕是go的runtime也不例外。将这些goroutines按照一定算法放到“CPU”上执行的程序就称为goroutine调度器或goroutine scheduler
 关于goroutine调度器 https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/  </description>
    </item>
    
  </channel>
</rss>