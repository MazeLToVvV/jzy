<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GO Jzy</title>
    <link>https://YoungJzy.github.io/</link>
    <description>Recent content on GO Jzy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2019 Jzy.</copyright>
    <lastBuildDate>Thu, 28 Mar 2019 14:40:23 +0800</lastBuildDate>
    
	<atom:link href="https://YoungJzy.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>取整</title>
      <link>https://YoungJzy.github.io/golang/%E5%8F%96%E6%95%B4/</link>
      <pubDate>Wed, 27 Mar 2019 16:26:14 +0800</pubDate>
      
      <guid>https://YoungJzy.github.io/golang/%E5%8F%96%E6%95%B4/</guid>
      <description>golang中的向上取整，向下取整，以及四舍五入
概述  官方的math包只给了向上和向下取整，分别是math.Ceil()[向上取整]，math.Floor()[向下取整]，并没有四舍五入的直接方法，但是我们可以通过向下取整变相的实现四舍五入。  用法 package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main(){ x := 1.1 fmt.Println(math.Ceil(x)) // 输出为2 fmt.Println(math.Floor(x)) // 输出为1 }  四舍五入  Word&amp;rsquo;s cheap, show u my code  package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math&amp;quot; ) func main(){ x := 1.1 y := 1.6 fmt.Println(math.Floor(x + 0.5)) // 输出为1 fmt.Println(math.Floor(y + 0.5)) // 输出为2 }  简单的很让人舒服，很巧妙的方法。</description>
    </item>
    
    <item>
      <title>Goroutine的管理</title>
      <link>https://YoungJzy.github.io/golang/goroutine%E7%9A%84%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 22 Mar 2019 15:52:26 +0800</pubDate>
      
      <guid>https://YoungJzy.github.io/golang/goroutine%E7%9A%84%E7%AE%A1%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Goroutine调度器</title>
      <link>https://YoungJzy.github.io/goodposts/goroutine%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Thu, 28 Mar 2019 16:11:57 +0800</pubDate>
      
      <guid>https://YoungJzy.github.io/goodposts/goroutine%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description> 概述 Go采用了用户层轻量级thread或者说是类coroutine的概念来解决这些问题，Go将之称为”goroutine“。goroutine占用的资源非常小(Go 1.4将每个goroutine stack的size默认设置为2k)，goroutine调度的切换也不用陷入(trap)操作系统内核层完成，代价很低。因此，一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在goroutine中执行，哪怕是go的runtime也不例外。将这些goroutines按照一定算法放到“CPU”上执行的程序就称为goroutine调度器或goroutine scheduler
 关于goroutine调度器 https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/  </description>
    </item>
    
  </channel>
</rss>