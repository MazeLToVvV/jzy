<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>goodposts on GO Jzy</title>
    <link>https://YoungJzy.github.io/goodposts/</link>
    <description>Recent content in goodposts on GO Jzy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>(c) 2019 Jzy.</copyright>
    <lastBuildDate>Thu, 28 Mar 2019 15:01:02 +0800</lastBuildDate>
    
	<atom:link href="https://YoungJzy.github.io/goodposts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Goroutine调度器</title>
      <link>https://YoungJzy.github.io/goodposts/goroutine%E8%B0%83%E5%BA%A6%E5%99%A8/</link>
      <pubDate>Thu, 28 Mar 2019 16:11:57 +0800</pubDate>
      
      <guid>https://YoungJzy.github.io/goodposts/goroutine%E8%B0%83%E5%BA%A6%E5%99%A8/</guid>
      <description> 概述 Go采用了用户层轻量级thread或者说是类coroutine的概念来解决这些问题，Go将之称为”goroutine“。goroutine占用的资源非常小(Go 1.4将每个goroutine stack的size默认设置为2k)，goroutine调度的切换也不用陷入(trap)操作系统内核层完成，代价很低。因此，一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在goroutine中执行，哪怕是go的runtime也不例外。将这些goroutines按照一定算法放到“CPU”上执行的程序就称为goroutine调度器或goroutine scheduler
 关于goroutine调度器 https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/  </description>
    </item>
    
  </channel>
</rss>